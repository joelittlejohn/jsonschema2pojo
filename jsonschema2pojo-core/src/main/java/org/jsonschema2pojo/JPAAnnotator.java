/**
 * 
 */
package org.jsonschema2pojo;

import static java.lang.System.out;

import java.lang.annotation.Annotation;
import java.util.Calendar;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Version;

import org.jsonschema2pojo.AbstractAnnotator;
import org.jsonschema2pojo.util.NameHelper;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.sun.codemodel.ClassType;
import com.sun.codemodel.JAnnotationArrayMember;
import com.sun.codemodel.JAnnotationUse;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JType;
import com.sun.codemodel.JVar;

/**
 * @author Labi0@github.com
 * This class is aggressively biased towards using ManyToOne
 * Supports the following features:
 *  Schema with "embeddable: true" will be treated as a component.
 *  Numeric fields named "id" will be annotated with Id.
 *  Numeric fields named "version" will be annotated with Version.
 *  Date fields named createdAt, and modifiedAt
 *  
 *  Supports "ext" attribute in schema- it is an array that contain one or more of the following
 *   notInsertable, unique, notUpdatable, Lob, "one-to-many", "one-to-one", "many-to-one", "many-to-many", readOnly
 *   Supports "mappedBy" attribute
 *   
 *   Rules for association:
 *    The association from the current-class point of view is termed as "this-side", 
 *     the association from the other class point of view is termed as "other-side"
 *     -association on this side is considered many-to-one if:
 *      - current field reference is NOT a collection 
 *        AND 
 *        (
 *        If there is no reference from the other-side to this-side
 *        OR
 *       -if there is more than one field on this-side that references the class of the current-field
 *       - and each reference on this side is not a collection 
 *         OR
 *      -if there is a collection-reference to this class from the other side
 *        )
 *    
 */
public class JPAAnnotator extends AbstractAnnotator {
  public final static Class<Integer> DEFAULT_ID_CLASS = Integer.class;
  public final static String EXT = "ext";
  private NameHelper nameHelper;
  
  
  public JPAAnnotator(NameHelper _nameHelper) {
    this.nameHelper = _nameHelper;
  }

  @Override
  public void propertyOrder(JDefinedClass clazz, JsonNode propertiesNode) {
    if(isEnum(clazz)) {
      return;
    }
    JMethod prePersistMethod = clazz.method(JMod.PUBLIC, Void.TYPE, "prePersist");
    prePersistMethod.annotate(PrePersist.class);
    JMethod preUpdateMethod = clazz.method(JMod.PUBLIC, Void.TYPE, "preUpdate");
    preUpdateMethod.annotate(PreUpdate.class);
    // provide support for pre-persist and pre-update for createdAt and modifiedAt fields
    JClass calClazz = clazz.owner().ref(Calendar.class);
    boolean hasIdField = false;
    for(Map.Entry<String, JFieldVar> fieldEntry: clazz.fields().entrySet()) {
      String fieldName = fieldEntry.getKey();
      JFieldVar fieldVar = fieldEntry.getValue();
      if(hasAnnotation(fieldVar, Id.class)) {
        hasIdField = true;
      }
      if(fieldName.equalsIgnoreCase("createdAt") || fieldName.equalsIgnoreCase("modifiedAt")) { 
        prePersistMethod.body().assign(fieldVar, 
            calClazz.staticInvoke("getInstance").invoke("getTime"));
        if(fieldName.equalsIgnoreCase("modifiedAt")) {
          preUpdateMethod.body().assign(fieldVar, 
              calClazz.staticInvoke("getInstance").invoke("getTime"));
        }
      }
    }
    if(!hasIdField) {//provide id field if none exists!
      //add id-field if it is none existing
      JFieldVar idFieldVar = clazz.field(JMod.PRIVATE, DEFAULT_ID_CLASS, "id");
      idFieldVar.annotate(Id.class);
      idFieldVar.annotate(GeneratedValue.class);
      idFieldVar.javadoc().append("Generated by JPAAnnotator to support JPA-Entity requirements.");
      //add getter
      JMethod getMethod = clazz.method(JMod.PUBLIC, DEFAULT_ID_CLASS, "getId");
      getMethod.body()._return(idFieldVar);
      //add setter
      JMethod setMethod = clazz.method(JMod.PUBLIC, Void.TYPE, "setId");
      JVar idParam = setMethod.param(DEFAULT_ID_CLASS, "_id");
      setMethod.body().assign(idFieldVar, idParam);
      //setMethod.body()._return();
    }
    
    //apply association annotations
    Map<String, JFieldVar> fields = clazz.fields();
    for (Iterator<String> properties = propertiesNode.fieldNames(); properties.hasNext();) {
      String nodeName = properties.next();
      String propertyName = nameHelper.getPropertyName(nodeName);
      JFieldVar propField = fields.get(propertyName);
      assert propField!= null;
      applyAssociationAnnotation(propField,clazz, propertyName, propertiesNode.get(propertyName));
    }

  }

  @Override
  public void propertyInclusion(JDefinedClass clazz, JsonNode schema) {
    if(isEnum(clazz)) {
      return;
    }
    else {
      clazz.annotate(Entity.class); //clazz.annotate(JsonInclude.class).param("value", JsonInclude.Include.NON_NULL);
    }
  }
  
  public static int indexOf(JsonNode[] items, String value) {
    int result = -1;
    for(int ai=0; ai < items.length; ai++) {
      if(items[ai].textValue().equalsIgnoreCase(value)) {
        result = ai;
        break;
      }
    }
    return result;
  }
  
  /**
   * Returns an actual generic-type if existing otherwise returns the specified type
   * @param jtype
   * @return
   */
  public static JClass getGenericType(JType type) {
    JClass typeClass = jclass(type);
    List<JClass> typeParams = typeClass.getTypeParameters();
    return (typeParams.size()>0?typeParams.get(0):typeClass);
  }
  
  public static JClass jclass(JType type) {
    return type.isPrimitive()? type.boxify() : (JClass) type;
  }
  
  /**
   * I had to create a separate method for jpa-association annotation because 
   * the calls at the property-level are sequential and the fields are not all there initially.
   * The fields are added as each property in the json-schema-node-properties gets processed.
   * @param field
   * @param clazz
   * @param propertyName
   * @param propertyNode
   */
  public void applyAssociationAnnotation(JFieldVar field, JDefinedClass clazz, String propertyName, JsonNode propertyNode) {
    boolean isCollection = isCollectionType(field.type());
    JClass fieldClass = isCollection? ((JClass)field.type()).getTypeParameters().get(0) : jclass(field.type());//
    
    out.println("applyAssociationAnnotation: "+clazz.fullName()+"::"+propertyName+"::collection?"+isCollection+"::type="+fieldClass.fullName());
    if(!propertyName.equalsIgnoreCase("id") && 
        !(propertyName.equalsIgnoreCase("version")&& isNumber(field.type())) &&
        !fieldClass.fullName().startsWith("java.") && !isEnum(fieldClass)) {
      out.println("applyAssociationAnnotation: milestone1");
      Class<? extends Annotation> associationAnnotation = null;
      Class<? extends Annotation> suggestedAnnotation = null;
      boolean cascadeDelete = false;
      String mappedBy = propertyNode.has("mappedBy")? propertyNode.get("mappedBy").asText() : null;
      
      JsonNode extensions = propertyNode.get("ext");
      if(extensions != null) {
        JsonNode[] extItems = null;
        if(extensions.isArray()){
          ArrayNode extNode = ((ArrayNode) extensions);
          final int extSize = extNode.size();
          extItems = new JsonNode[extNode.size()];
          for (int ai=0; ai < extSize; ai++) {
            extItems[ai] = extNode.get(ai);
          }
        } else if(extensions.isTextual()){
          extItems = new JsonNode[]{extensions};
        } else {
          throw new RuntimeException("unsupported extensions: "+extensions.toString());
        }
        final boolean[] processesIndices = new boolean[extItems.length];
        int processedIndex = -1;
        if((processedIndex= indexOf(extItems, "one-to-many")) > -1) {
          suggestedAnnotation = OneToMany.class;
          processesIndices[processedIndex] = true;
        }else if ((processedIndex= indexOf(extItems, "one-to-one")) > -1) {
          suggestedAnnotation = OneToOne.class;
          processesIndices[processedIndex] = true;
        }else if ((processedIndex= indexOf(extItems, "many-to-one")) > -1) {
          suggestedAnnotation = ManyToOne.class;
          processesIndices[processedIndex] = true;
        }else if ((processedIndex= indexOf(extItems, "many-to-many")) > -1) {
          suggestedAnnotation = ManyToMany.class;
          processesIndices[processedIndex] = true;
        }
        if(!fieldClass.fullName().startsWith("java.") && !isEnum(fieldClass) && suggestedAnnotation != null) {
         throw new RuntimeException("Cannot perform JPA association for java-classes or enum."+
        " In this case, annotation is "+suggestedAnnotation+" for field "+propertyName+" an instance of "+fieldClass.fullName()+
        ", inside entity: "+clazz.fullName()); 
        }
        StringBuilder sb= new StringBuilder();
        boolean isFirstAppend = true;
        for(int ai=0; ai < processesIndices.length; ai++) {
          if(!processesIndices[ai]) {
            if(!isFirstAppend) {
              sb.append(", \n");
            }
            sb.append(extItems[ai]);
            isFirstAppend = false;
          }
        }
        if(!isFirstAppend) {
          System.err.println("Did not process the following extensions.items: "+sb.toString());
        }
      }
      
      if(suggestedAnnotation == null) {
          boolean clazzHasMultipleRefToFieldClass = false;
          boolean clazzHasCollectionRefToFieldClass= isCollection;
          int countCollectionRefToFieldClass = isCollection? 1:0;
          
          for(Map.Entry<String, JFieldVar> entry: clazz.fields().entrySet()) {
            JFieldVar clazzFieldVar = entry.getValue();
            if(clazzFieldVar.type().equals(fieldClass) && !entry.getKey().equals(field.name())) {
              clazzHasMultipleRefToFieldClass = true;
              if(isCollectionType(clazzFieldVar.type())) {
                countCollectionRefToFieldClass++;
                clazzHasCollectionRefToFieldClass = true;
              }
            }
          }
          if(countCollectionRefToFieldClass > 1) {
            throw new RuntimeException("Invalid JPA-Mapping error, class: "+clazz.fullName()+
                " has multiple collection references to class: "+fieldClass.fullName());
          }
          boolean isSelfReference = fieldClass.equals(clazz);
          boolean fieldClassHasRefToClazz = isSelfReference;//null implies none, true=> many, and false => one //finds the first
          boolean fieldClassHasMultipleRefToClazz = false;
          boolean fieldClazzHasCollectionRefToClazz= false;
          int countFieldClazzCollectionRefToClazz = 0;
          if(fieldClass instanceof JDefinedClass) {
            
            for(Map.Entry<String, JFieldVar> fieldClassField: ((JDefinedClass) fieldClass).fields().entrySet()) {
              if(isSelfReference && fieldClassField.getKey().equals(field.name())) {
                continue;
              }
              JFieldVar otherSideFieldVar = fieldClassField.getValue();
              JType otherSideType = otherSideFieldVar.type();
              boolean otherSideFieldIsCollection = isCollectionType(otherSideType);
              JClass otherSideFieldClass = otherSideFieldIsCollection? getGenericType(otherSideType) : jclass(otherSideType);
              if(otherSideFieldClass.equals(clazz)) {
                fieldClassHasMultipleRefToClazz = fieldClassHasRefToClazz;//bcos fieldClassHasRefToClazz is true, only if this is not first time
                fieldClassHasRefToClazz = true;
                fieldClazzHasCollectionRefToClazz = (fieldClazzHasCollectionRefToClazz || otherSideFieldIsCollection);
                if(otherSideFieldIsCollection) {
                  countFieldClazzCollectionRefToClazz++;
                  mappedBy = fieldClassField.getKey();
                } else if(countFieldClazzCollectionRefToClazz == 0 && !fieldClassHasMultipleRefToClazz) { //no other field
                  mappedBy = fieldClassField.getKey(); //only field that is associated with that record
                }
                /*Class<? extends Annotation>  entityAssociation = getEntityAssociationAnnotation(otherSideFieldVar.annotations());
                if(entityAssociation != null) {
                  mappedBy = fieldClassField.getKey();
                  if(associationAnnotation == null) {
                    associationAnnotation = entityAssociation;
                  } //Can't requires this-side to have same relationship with the other-side to always have same relationshipelse 
                  else if(associationAnnotation.equals(entityAssociation) && 
                      !associationAnnotation.equals(OneToOne.class)) { //only one-to-one relationship can be symetric
                    String msg = "JPA association annotation mismatch: "+clazz.fullName()+":"+propertyName+
                        " specified annotation is "+associationAnnotation.getSimpleName()+"; "+
                        " other-side class is "+otherSideFieldClass.fullName()+":"+fieldClassField.getKey()+
                        ", specified annotation is "+entityAssociation.getSimpleName();
                    throw new RuntimeException(msg);
                  }
                }*/
              }
            }
            if(countFieldClazzCollectionRefToClazz > 1) {
              throw new RuntimeException("Invalid JPA-Mapping error, class: "+fieldClass.fullName()+
                  " has multiple collection references to class: "+clazz.fullName());
            }
          }
          //available variables:
          // clazzHasMultipleRefToFieldClass, clazzHasCollectionRefToFieldClass
          // isSelfReference fieldClassHasRefToClazz fieldClassHasMultipleRefToClazz  fieldClazzHasCollectionRefToClazz
          
            Class<? extends Annotation> deducedAssociationAnnotation = null;

            boolean toMany = false;
            boolean fromMany = false;
            if(isCollection) {
              if(clazzHasMultipleRefToFieldClass) {
                toMany = true;
              }else {
                toMany = true;
              }
            } else {
              toMany = false;
            }
            if(!isCollection && clazzHasMultipleRefToFieldClass) {
              fromMany = true;
            } 
            else if(fieldClassHasRefToClazz) { //potential bi-directional field
              if(fieldClazzHasCollectionRefToClazz) {
                fromMany = true;
              }
              else {
                fromMany = false;
              }
            } else if(!isCollection){ //aggressively uses manyToOne unless there are two sides or collection-field
              fromMany = true;
              cascadeDelete = true;//since field-class has no reference to the current-class
            }else {
              fromMany = false;
            }
            if(fromMany) {
              deducedAssociationAnnotation = (toMany? ManyToMany.class : ManyToOne.class);
            } else {
              deducedAssociationAnnotation = (toMany? OneToMany.class : OneToOne.class);
            }
            //only need mappedBy for one-to-one and many-to-many
            associationAnnotation = deducedAssociationAnnotation;
            
            if(fromMany != toMany) { //NOT one-to-one or many-to-many, //mapped-by is NOT wanted
              mappedBy = null;//deliberately setting to null
            } 
        } else {
          associationAnnotation = suggestedAnnotation;
          
          JAnnotationUse associationAnnotUse = field.annotate(suggestedAnnotation);
          if(mappedBy != null) {
            associationAnnotUse.param("mappedBy", mappedBy);
          }
        }
      JAnnotationUse associationAnnotUse = field.annotate(associationAnnotation);
      if(mappedBy != null) {
        associationAnnotUse.param("mappedBy", mappedBy);
      }
      //if(deduce)
      JAnnotationArrayMember cascadeParam = associationAnnotUse.paramArray("cascade"); //param("cascade", cascadeParamValue);
      cascadeParam = cascadeParam.param(CascadeType.PERSIST).param(CascadeType.DETACH).param(CascadeType.MERGE).param(CascadeType.REFRESH);
      if(associationAnnotation.equals(OneToMany.class) || cascadeDelete) {
        cascadeParam.param(CascadeType.REMOVE);
      }
    }
  }

  @Override
  public void propertyField(JFieldVar field, JDefinedClass clazz, String propertyName, JsonNode propertyNode) {
    if(propertyName.equalsIgnoreCase("id")) {
      field.annotate(Id.class);
      if(isNumber(field.type())) {
        field.annotate(GeneratedValue.class);
      }
    }
    else if(propertyName.equalsIgnoreCase("version") && isNumber(field.type())) {
      field.annotate(Version.class);
    }
    else {
      //column related processing
      JAnnotationUse columnAnnotation = null;
      if(is(propertyNode, "required")) {
        columnAnnotation = field.annotate(Column.class);
        columnAnnotation.param("nullable", false);
      }
      JsonNode maxLength = propertyNode.get("maxLength");
      if(maxLength != null) {
        if(columnAnnotation == null) {
          columnAnnotation = field.annotate(Column.class);
        }
        columnAnnotation.param("length", maxLength.asInt());
      }
      boolean isCollection = isCollectionType(field.type());
      JClass fieldClass = isCollection? getGenericType(field.type()) : jclass(field.type());
      JsonNode extensions = propertyNode.get("ext");
      if(extensions != null) {
        JsonNode[] extItems = null;
        if(extensions.isArray()){
          ArrayNode extNode = ((ArrayNode) extensions);
          final int extSize = extNode.size();
          extItems = new JsonNode[extNode.size()];
          for (int ai=0; ai < extSize; ai++) {
            extItems[ai] = extNode.get(ai);
          }
        } else if(extensions.isTextual()){
          extItems = new JsonNode[]{extensions};
        } else {
          throw new RuntimeException("unsupported extensions: "+extensions.toString());
        }
        final boolean[] processesIndices = new boolean[extItems.length];
        int processedIndex = -1;

        if((processedIndex= indexOf(extItems, "unique")) > -1) {
          if(columnAnnotation == null) {
            columnAnnotation = field.annotate(Column.class);
          }
          columnAnnotation.param("unique", true);
          processesIndices[processedIndex] = true;
        }
        if((processedIndex= indexOf(extItems, "notInsertable")) > -1) {
          if(columnAnnotation == null) {
            columnAnnotation = field.annotate(Column.class);
          }
          columnAnnotation.param("insertable", false);
          processesIndices[processedIndex] = true;
        }
        if((processedIndex= indexOf(extItems, "notUpdatable")) > -1) {
          if(columnAnnotation == null) {
            columnAnnotation = field.annotate(Column.class);
          }
          columnAnnotation.param("updatable", false);
          processesIndices[processedIndex] = true;
        }
        if((processedIndex= indexOf(extItems, "lob")) > -1) {
          field.annotate(Lob.class);
        }

        if(!fieldClass.fullName().startsWith("java.") && !isEnum(fieldClass)) {
          if((processedIndex= indexOf(extItems, "one-to-many")) > -1) {
            processesIndices[processedIndex] = true;
          }else if ((processedIndex= indexOf(extItems, "one-to-one")) > -1) {
            processesIndices[processedIndex] = true;
          }else if ((processedIndex= indexOf(extItems, "many-to-one")) > -1) {
            processesIndices[processedIndex] = true;
          }else if ((processedIndex= indexOf(extItems, "many-to-many")) > -1) {
            processesIndices[processedIndex] = true;
          }
        }
        StringBuilder sb= new StringBuilder();
        boolean isFirstAppend = true;
        for(int ai=0; ai < processesIndices.length; ai++) {
          if(!processesIndices[ai]) {
            if(!isFirstAppend) {
              sb.append(", \n");
            }
            sb.append(extItems[ai]);
            isFirstAppend = false;
          }
        }
        if(!isFirstAppend) {
          System.err.println("Ignoring the following extensions.items: "+sb.toString());
        }
      }
    }
  }
  
  public static boolean isComponent(JType type) {
    JDefinedClass clazz = (type instanceof JDefinedClass ? (JDefinedClass) type : null);
    if(clazz == null) {
      return false;
    }
    boolean result = true;
    //refrences only primitives and enum
    Map<String, JFieldVar> fields = clazz.fields();
    if(fields.size() > 6) {
      result = false;
    }
    else {
      for(Map.Entry<String, JFieldVar> field: fields.entrySet()) {
        JFieldVar fieldVar = field.getValue();
        JType fieldType = isCollectionType(fieldVar.type())? getGenericType(fieldVar.type())  : fieldVar.type();
        if(fieldType.fullName().startsWith("java.") || isEnum(jclass(fieldType)) || fieldType.unboxify().isPrimitive()) {
          continue;
        }
        if(fieldType instanceof JDefinedClass) {
          result = true;
          break;
        }
      }
    }
    return result;
  }
  
  public boolean hasAnnotation(JType type, Class<? extends Annotation> annotation) {
    String fullClassName = annotation.getName();
    boolean result = false;
    if(type instanceof JDefinedClass) {
      Collection<JAnnotationUse> annotations = ((JDefinedClass) type).annotations();
      for(JAnnotationUse annotationUse : annotations) {
        if(annotationUse.getAnnotationClass().fullName().equals(fullClassName)) {
          result = true;
          break;
        }
      }
    }
    return result;
  }
  
  public static boolean hasAnnotation(JFieldVar fieldVar, Class<? extends Annotation> annotationClass) {
    String fullClassName = annotationClass.getName();
    boolean result = false;
    Collection<JAnnotationUse> annotations = fieldVar.annotations();
    for(JAnnotationUse annotationUse : annotations) {
      if(annotationUse.getAnnotationClass().fullName().equals(fullClassName)) {
        result = true;
        break;
      }
    }
    return result;
  }
  
  public static Class<? extends Annotation> getEntityAssociationAnnotation(Collection<JAnnotationUse> annotations) {
    Class<? extends Annotation> result = null;
    for(JAnnotationUse annotationUse : annotations) {
      if(annotationUse.getAnnotationClass().fullName().equals(OneToOne.class.getName())) {
        result = OneToOne.class;
        break;
      } else if(annotationUse.getAnnotationClass().fullName().equals(OneToMany.class.getName())) {
        result = OneToMany.class;
        break;
      } else if(annotationUse.getAnnotationClass().fullName().equals(ManyToOne.class.getName())) {
        result = ManyToOne.class;
        break;
      } else if(annotationUse.getAnnotationClass().fullName().equals(ManyToMany.class.getName())) {
        result = ManyToMany.class;
        break;
      }
    }
    return result;
  }

  public static boolean is(JsonNode targetNode, String field) {
    return (targetNode.has(field) && targetNode.get(field).asBoolean());
  }

  public static boolean isCollectionType(JType type) {
    boolean result = false;
    JClass typeClass = jclass(type); //jclass(type)
    result = ((JClass)typeClass.owner()._ref(Collection.class)).isAssignableFrom(typeClass);
    return result;
  }
  
  public static boolean isEnum(JClass clazz) {
    boolean result = false;
    if(clazz instanceof JDefinedClass) {
      result = ((JDefinedClass) clazz).getClassType().equals(ClassType.ENUM);
    } else {
      try{
        Class<?> _class = Class.forName(clazz.fullName());
        result = _class.isEnum();
      }catch(ClassNotFoundException cnfe){}
    }
    //System.out.println(clazz.fullName()+" is "+(result?"": "not ")+"an enum");
    return  result;
  }
  
  public boolean isNumber(JType type) {
    boolean result = false;
    JClass typeClass = jclass(type);
    result = ((JClass)typeClass.owner()._ref(Number.class)).isAssignableFrom(typeClass);
    return result;
  }
}
